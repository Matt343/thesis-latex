% TEMPLATE for Usenix papers, specifically to meet requirements of
% USENIX '05
% originally a template for producing IEEE-format articles using LaTeX.
% written by Matthew Ward, CS Department, Worcester Polytechnic Institute.
% adapted by David Beazley for his excellent SWIG paper in Proceedings,
% Tcl 96
% turned into a smartass generic template by De Clarke, with thanks to
% both the above pioneers
% use at your own risk.  Complaints to /dev/null.
% make it two column with no page numbering, default is 10 point

% Munged by Fred Douglis <douglis@research.att.com> 10/97 to separate
% the .sty file from the LaTeX source template, so that people can
% more easily include the .sty file into an existing document.  Also
% changed to more closely follow the style guidelines as represented
% by the Word sample file. 

% Note that since 2010, USENIX does not require endnotes. If you want
% foot of page notes, don't include the endnotes package in the 
% usepackage command, below.

\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{epsfig,endnotes}
\usepackage[toc,page]{appendix}
\begin{document}

% don't want date printed
\date{}

% make title bold and 14 pt font (Latex default is non-bold, 16 pt)
\title{\Large \bf Parametric Polymorphism in the Go Programming Language}

\author{
  {\rm Matthew Allen}\\
  University of Texas
  \and
  {\rm Jan Rellermeyer}\\
  Second Institution
}

\maketitle

% Use the following at camera-ready time to suppress page numbers.
% Comment it out when you first submit the paper for review.
\thispagestyle{empty}


\subsection*{Abstract}
Your Abstract Text Goes Here.  Just a few facts.
Whet our appetites.

\section{Introduction} \label{introduction}

Strong, static type systems offer the programmer the ability to reason about the kinds of data that a program operates on and ensure that only valid data us used to perform calculations. When using a language with a strong, static type system, there are certain guarantees of correctness that are offered, and certain classes of errors that can be detected at compile time rather than at run time. As with any form of static analysis, compile time type checking cannot completely understand the semantics of the program, and so it must be conservative in rejecting potentially valid programs to ensure that type errors cannot occur. If a language implements an overly simplistic static type system, the valid constructs that cannot be expressed within the type system prevent the programmer from writing clear, expressive, and reusable code. In this case, the drawbacks of a strong type system may outweigh the benefits. By adding more power to the type system, the language can become more expressive and the type system can be less of a burden on the programmer. Parametric polymorphism is a common feature of strong type systems that allows functions or data structures to be written generically, so that they can operate on values of many types while still maintaining static type safety. Generic functions and data structures have type parameters which are substituted for specific types when the function or data structure is used. These type parameters may be bounded, so that only a certain class of types can be used for a type parameter, which allows the generic construct to use some common features of its parameterized types.

\section{Motivation} \label{motivation}

Go features a strong static type system, but the semantics of the type system are quite limited. Without a way to use parametric polymorphism, it is impossible to write statically type checked functions that can be reused for multiple similar types. This leads programmers to either duplicate code many times to create separate, specialized versions of otherwise identical functions or bypass the static type system using casting and reflection. Both of these approaches have practical drawbacks compared to generic programming, and they introduce increased potential for errors. In this paper, we outline an extension to the Go language that includes generic functions that are statically checked, but transformed into standard Go code at compile time. 

Since Go is a compile language, changes to the language specification must be accomplished by changing the compiler(s) that implement the language. The new language constructs needed to implement generic functions require changes to the grammar that defines valid Go programs, so the parser for the language must be updated, and new node types must be added to the abstract syntax tree (AST) of the language. These changes to the parser are outlined in section \ref{parsing}. Once the compiler can parse the new language constructs, the type checking system must be updated with the new type rules. These changes to the type checking system in the compiler are detailed in section \ref{type_checking}. Section \ref{code_generation} explains the changes needed to generate generic code correctly, as well as the trade offs for different code generation strategies. 

\section{Compiler Architecture} \label{architecture}

There are several compiler implementations for the Go language, each with different advantages and drawbacks. The main compiler is referred to as the Go Compiler, or GC, and is the original version of the compiler. Originally written in C, GC has been made self-hosting in Go version 1.5, and it is now written almost entirely in Go. Unfortunately, the process for transitioning GC from C to Go was mostly automated, and as a result the codebase has not truly made use of the features or advantages that Go has over C. One important consequence of this is that the compiler does not use the parsing and type checking libraries for Go code that are included in the standard library, and the code for performing these tasks is relatively tightly coupled with other parts of the system. For this reason, adding new features to the GC system is difficult, and a significant amount of work would have to be dedicated to working around the complexities of the C-like software design.

 Another major compiler implementation is GCCGo, which is a Go frontend for the GNU Compiler Collection (GCC). GCCGo is written in C++, and is written in the style of the GCC codebase. Since GCCGo is written in C++, it also does not make use of the parsing and type checking libraries from the Go standard library. As a GCC frontend, the compiler inherits much of the complexity that is required of such a flexible compiler, and modifications to it must account for this overhead.

I chose to modify a less commonly used community compiler, LLGO, which is a frontend for the LLVM compiler system. LLGO is written in Go, and since it uses the standard library parsing and type checking systems it was the easiest system to add modifications to and extend. Since the goal of this project was to provide a proof of concept for a generic system in Go, I chose to sacrifice widespread usage in favor of ease of development and prototyping speed.

The LLGO compiler consists of an implementation of the Go runtime, and a frontend compiler that emits LLVM intermediate representation (IR). The main command program emulates the command line API of GC and GCCGo, providing support for resolving dependencies, building packages, and linking programs. When a program is processed by the compiler, it first invokes the parser on the input files to generate a canonical AST for the program. Next, the type checker is invoked on the AST, which generates type information for each expression and definition and ensures that all of they rules of the type system are followed. Once they type information has been generated, the AST is transformed into a single static assignment (SSA) form, which makes the AST more compatible with the SSA form of the LLVM IR. At this stage the LLVM specific translation occurs, generating IR from the SSA form of the program that can be fed into the LLVM system. LLVM includes many compiler passes that perform optimization and improve the final code generation, and several of these passes are used to implement the compiler optimization for LLGO. Finally, the LLVM system outputs an executable, binary version of the input program. This architecture provides a reasonable level of modularity and separation of the various parts of the compilation process. The modularity of the system makes it much easier to implement new features in discrete parts, and provide ways to test the individual parts of the system in isolation.

\section{Parsing} \label{parsing}

The first change that was required to implement generic functions was to extend the parser to support the new language constructs. The Go standard library contains a module, \texttt{go/parser}, that implements a recursive descent parser for the Go language grammar. The language grammar was designed to be an LL(1) grammar, that is, it can be parsed by a recursive descent parser with single element lookahead and no backtracking in linear time. The parser, therefore, is implemented without support for backtracking. To avoid an extensive redesign of the existing parser, the extensions to the language are constrained to keep the grammar within the requirements for an LL(1) grammar. The practice consequence of this is that new rules must not introduce ambiguity between productions. Compromises were made to the syntax of the extensions to ensure that minimal changes to existing parsing code were required, and the new grammar is backwards compatible with the existing grammar.

The syntax for generic function definitions and for specifying type parameters at call sites is similar to the generic syntax in Java and C$\sharp$. Angled brackets (`\textbf{$<$}' and `\textbf{$>$}') were chosen as delimiters for the type parameter sections in function signatures and calls. The other common delimiters (`\textbf{(}', `\textbf{[}' and `\textbf{\{}') are all part of existing language constructs that are valid after identifiers (function calls, index expressions, and composite literals, respectively) so they could not be used without introducing ambiguity or making more extensive changes to the grammar. Angled brackets also have the advantage of producing less confusion for the programmer, as they are not used as delimiters anywhere else in the grammar. The function type signature, which includes the arguments and return type of a function, was extended to include an optional section for type parameters and their type bounds. This allows type parameters to be included in both function definitions and function literals, as well as function types for fields and parameters. Unfortunately, the `\textbf{$<$}' character cannot be unambiguously parsed as either the start of a list of type arguments or the less than operator when it occurs after an identifier. For this reason, the type arguments to a function call are supplied as part of the argument list, after the opening parenthesis of the call expression. This syntax is inelegant, but it allows for unambiguous parsing with minimal grammar rewriting, and the type inference features of the language mean that in many cases the entire type parameter section of the call can be omitted and inferred based on the argument types.

One other issue that had to be addressed to allow for these grammar extensions is introduced by the lexer, which translates the source file into a list of tokens for easier parsing. Since `\textbf{$>>$}' is a token used for bit-shifting, the parser must be able to accept `\textbf{$>>$}' or  `\textbf{$>$}' when consuming closing brackets in nested type parameter sections. This is accomplished by tracking whether or not the parser is inside a nested type parameter list, and allowing  `\textbf{$>>$}' to close the inner and outer parameter lists. Using this system, there is no risk of the right shift operator being mistaken for a part of a parameter list, as it is not valid in type signatures, and any combination of single or double angle brackets can be parsed correctly.

The complete changes to the Go grammar are included in Appendix \ref{App:grammar}.

\section{Type Checking} \label{type_checking}

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\section{Code Generation} \label{code_generation}

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\subsection{AST Transformation} \label{ast_transformation}

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\subsection{Type Erasure} \label{type_erasure}

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\subsection{Reflection} \label{reflection}

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\section{Results} \label{results}
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\section{Conclusion and Future Work} \label{conclusion}
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

{\footnotesize \bibliographystyle{acm}
  \bibliography{sample}}

\theendnotes


\begin{appendices}

\section{Modified Grammar} \label{App:grammar}

\end{appendices}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:


% {\tt \small
% \begin{verbatim}
% #include <iostream>
% using namespace std;
% main()
% {
% cout << "Hello world \n";
% return 0;
% }

% \end{verbatim}
% }
